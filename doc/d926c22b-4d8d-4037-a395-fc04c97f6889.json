{
    "summary": "The code defines an app object with Chrome extension functions, handles browser actions and commands, includes hotkey listeners, manages tab events for installations/updates, sets up communication between popup and background scripts using Chrome storage and messaging.",
    "details": [
        {
            "comment": "This code defines an application object with various functions and properties. It uses the Chrome extension API to interact with browser actions, web requests, and commands. The app version and homepage URL can be retrieved using respective functions. A hotkey listener is implemented for toggling a default mode. Web request listeners are added or removed based on a flag.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":0-28",
            "content": "var app = {};\napp.version = function () {return chrome.runtime.getManifest().version};\napp.homepage = function () {return chrome.runtime.getManifest().homepage_url};\napp.hotkey = function (callback) {\n  chrome.commands.onCommand.addListener(function (e) {\n    if (e === \"toggle-default-mode\") {\n      callback(\"_mode\");\n    }\n  });\n};\napp.webrequest = {\n  \"listener\": function () {\n    chrome.webRequest.onHeadersReceived.removeListener(core.listener.headers.received);\n    chrome.webRequest.onBeforeSendHeaders.removeListener(core.listener.before.send.headers);\n    /*  force on. */\n    if (true) {\n      chrome.webRequest.onHeadersReceived.addListener(core.listener.headers.received, config.addon.URLS, config.addon.OPTIONS.response);\n      chrome.webRequest.onBeforeSendHeaders.addListener(core.listener.before.send.headers, config.addon.URLS, config.addon.OPTIONS.request);\n    }\n  }\n};\napp.button = {\n  \"title\": function (text) {chrome.browserAction.setTitle({\"title\": text})},\n  \"badge\": function (state) {\n    chrome.browserAction.setIcon({"
        },
        {
            "comment": "The code defines an object \"app\" with methods for handling origin, hostname, and tabs. The \"path\" property holds different icon sizes based on the given state. The \"app.origin\" method retrieves the protocol and hostname from a URL. The \"app.hostname\" method extracts the hostname from a URL after removing \"www.\". Lastly, the \"app.tab.open\" function opens a new tab with the provided URL.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":29-68",
            "content": "      \"path\": {\n        \"16\": \"../../data/icons\" + (state ? '/' + state : '') + \"/16.png\",\n        \"32\": \"../../data/icons\" + (state ? '/' + state : '') + \"/32.png\",\n        \"48\": \"../../data/icons\" + (state ? '/' + state : '') + \"/48.png\",\n        \"64\": \"../../data/icons\" + (state ? '/' + state : '') + \"/64.png\"\n      }\n    });\n  }\n};\napp.origin = function (url) {\n  if (url) {\n    var path = url.split('/');\n    if (path && path.length) {\n      var protocol = path[0];\n      var hostname = path[2];\n      return protocol + \"//\" + hostname;\n    }\n  }\n  /*  */\n  return '*';\n};\napp.hostname = function (url) {\n  url = url ? url.replace(\"www.\", '') : url;\n  var s = url.indexOf(\"//\") + 2;\n  if (s > 1) {\n    var o = url.indexOf('/', s);\n    if (o > 0) return url.substring(s, o);\n    else {\n      o = url.indexOf('?', s);\n      if (o > 0) return url.substring(s, o);\n      else return url.substring(s);\n    }\n  } else return url;\n};\napp.tab = {\n  \"options\": {\"page\": function () {chrome.runtime.openOptionsPage()}},\n  \"open\": function (url) {chrome.tabs.create({\"url\": url, \"active\": true})},"
        },
        {
            "comment": "This code snippet provides a function \"checkURL\" that retrieves the current URL of a tab if it is available. If not, it uses chrome.tabs.executeScript to execute a script in the tab to get the URL. The \"active\" object contains two functions: \"reload\", which reloads the active tab, and \"query\", which queries for the currently active tab and calls checkURL on it if found. The code also sets an uninstall URL and listens for installation events. If the browser is not in webdriver mode, it sets an uninstall URL and handles the installed event.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":69-102",
            "content": "  \"checkURL\": function (tab, callback) {\n    if (tab.url) callback(tab);\n    else {\n      chrome.tabs.executeScript(tab.id, {\"code\": \"document.location.href\"}, function (result) {\n        var error = chrome.runtime.lastError;\n        if (result && result.length) {\n          tab.url = result[0];\n        }\n        /*  */\n        callback(tab);\n      });\n    }\n  },\n  \"active\": {\n    \"reload\": function () {chrome.tabs.reload({\"bypassCache\": true})},\n    \"query\": function (callback) {\n      chrome.tabs.query({\"currentWindow\": true, \"active\": true}, function (tabs) {\n        if (tabs && tabs.length) {        \n          app.tab.checkURL(tabs[0], function (tab) {\n            if (tab && tab.url) {\n              callback(tab);\n            }\n          });\n        }\n      });\n    }\n  }\n};\nif (!navigator.webdriver) {\n  chrome.runtime.setUninstallURL(app.homepage() + \"?v=\" + app.version() + \"&type=uninstall\", function () {});\n  chrome.runtime.onInstalled.addListener(function (e) {\n    chrome.management.getSelf(function (result) {\n      if (result.installType === \"normal\") {"
        },
        {
            "comment": "This code sets a timeout to check if the application is installed or updated within 3000 milliseconds. If it's an install or update within 45 days, it opens a new tab with the homepage URL and app version. The code also initializes the \"objs\" object by getting data from chrome.storage.local after a 0-second timeout. It then appends a script tag for \"common.js\".",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":103-131",
            "content": "        window.setTimeout(function () {\n          var previous = e.previousVersion !== undefined && e.previousVersion !== app.version();\n          var doupdate = previous && parseInt((Date.now() - config.welcome.lastupdate) / (24 * 3600 * 1000)) > 45;\n          if (e.reason === \"install\" || (e.reason === \"update\" && doupdate)) {\n            var parameter = (e.previousVersion ? \"&p=\" + e.previousVersion : '') + \"&type=\" + e.reason;\n            app.tab.open(app.homepage() + \"?v=\" + app.version() + parameter);\n            config.welcome.lastupdate = Date.now();\n          }\n        }, 3000);\n      }\n    });\n  });\n}\napp.storage = (function () {\n  var objs = {};\n  window.setTimeout(function () {\n    chrome.storage.local.get(null, function (o) {\n      objs = o;\n      var script = document.createElement(\"script\");\n      script.src = \"../common.js\";\n      document.body.appendChild(script);\n    });\n  }, 0);\n  /*  */\n  return {\n    \"read\": function (id) {return objs[id]},\n    \"write\": function (id, data) {\n      var tmp = {};"
        },
        {
            "comment": "This code appears to be setting up communication between the popup and background scripts using Chrome storage and messaging. The app.popup and app.options functions create message listeners for specific paths (\"popup-to-background\" and \"options-to-background\") and allow sending messages to those paths using app.popup.send() and app.options.send(). Data is stored temporarily in tmp before being processed by the corresponding function.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":132-168",
            "content": "      tmp[id] = data;\n      objs[id] = data;\n      chrome.storage.local.set(tmp, function () {});\n    }\n  }\n})();\napp.popup = (function () {\n  var tmp = {};\n  chrome.runtime.onMessage.addListener(function (request, sender, sendeponse) {\n    for (var id in tmp) {\n      if (tmp[id] && (typeof tmp[id] === \"function\")) {\n        if (request.path === \"popup-to-background\") {\n          if (request.method === id) tmp[id](request.data);\n        }\n      }\n    }\n  });\n  /*  */\n  return {\n    \"receive\": function (id, callback) {tmp[id] = callback},\n    \"send\": function (id, data) {\n      chrome.runtime.sendMessage({\"path\": \"background-to-popup\", \"method\": id, \"data\": data});\n    }\n  }\n})();\napp.options = (function () {\n  var tmp = {};\n  chrome.runtime.onMessage.addListener(function (request, sender, sendeponse) {\n    for (var id in tmp) {\n      if (tmp[id] && (typeof tmp[id] === \"function\")) {\n        if (request.path === \"options-to-background\") {\n          if (request.method === id) tmp[id](request.data);\n        }\n      }\n    }"
        },
        {
            "comment": "This code creates a function that handles receiving and sending messages. It uses Chrome runtime to send messages to \"background-to-options\" component, with the ability to assign callbacks for received messages.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/keller/src/ced/lib/chrome/chrome.js\":169-177",
            "content": "  });\n  /*  */\n  return {\n    \"receive\": function (id, callback) {tmp[id] = callback},\n    \"send\": function (id, data) {\n      chrome.runtime.sendMessage({\"path\": \"background-to-options\", \"method\": id, \"data\": data});\n    }\n  }\n})();"
        }
    ]
}