{
    "summary": "The code defines functions to return consecutive occurrences of input strings/bytes, creating a flattened list from nested parameters with multiprocessing support.",
    "details": [
        {
            "comment": "The code defines two functions: \"blackwhite\" and \"bw\". These functions take in one or two parameters, either string or bytes, and return a list of strings/bytes where each element represents consecutive occurrences of the parameter value. The functions handle both string and byte input types and have an optional boolean flag for inverting the output. The code also includes conditional print statements for debugging purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/blitx/cruncher.py\":0-40",
            "content": "# string first.\n#from numba import jit as  autojit\nimport multiprocessing\nimport time\n#@autojit(nopython=True, nogil=True)\ndef blackwhite(a,b,c=True):\n    byte=False\n    if type(a)==str:\n        assert type(b)==str\n    elif type(a)==bytes:\n        assert type(b)==bytes\n        byte=True\n    else:\n        return None\n    assert type(c)==bool\n    buf=\"\" if not byte else b\"\"\n    cb=[]\n    t=len(a)\n    for d in range(t):\n        x=a[d:d+1]\n        \"\"\"if d%1000==0:\n            print(\"byte\",d,\"total\",t)\"\"\"\n        if c:\n            if x in b:\n                buf+=x\n            elif (buf!=\"\" and not byte) or (buf!=b\"\" and byte):\n                cb.append(buf)\n                buf=\"\" if not byte else b\"\"\n        else:\n            if x not in b:\n                buf+=x\n            elif (buf!=\"\" and not byte) or (buf!=b\"\" and byte):\n                cb.append(buf)\n                buf=\"\" if not byte else b\"\"\n    if (buf!=\"\" and not byte) or (buf!=b\"\" and byte):\n        cb.append(buf)\n    return cb\n#@autojit(nopython=True, nogil=True)\ndef bw(a,b,d,e,c=True):"
        },
        {
            "comment": "The code defines a function `multibw` that takes in two arrays (or strings/bytes) and performs parallel processing on each slice of the input arrays. It uses multiprocessing to split the work into multiple processes, each handling a portion of the input arrays. The code also provides an alternative threading-based implementation within comments. The function returns None if the input types are incorrect or if the specified dimension `d` is invalid.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/blitx/cruncher.py\":41-81",
            "content": "    s=blackwhite(a,b,c)\n    e[d]=s\n#@autojit(nopython=True, nogil=True)\ndef multibw(a,b,d,c=True):\n    byte=False\n    if type(a)==str:\n        assert type(b)==str\n    elif type(a)==bytes:\n        assert type(b)==bytes\n        byte=True\n    else:\n        return None\n    assert type(c)==bool \n    l=len(a)\n    assert d<=l and d>1 and type(d)==int\n    r=l%d\n    s=l//d\n    k=[(x*s,(x+1)*s) for x in range(d-1)]\n    k+=[((d-1)*s,d*s+r)]\n    #param={x:None for x in range(d)}\n    mgr = multiprocessing.Manager()\n    param = mgr.dict()\n    for x in range(d):\n        param[x]=None\n    jobs = [multiprocessing.Process(target=bw, args=(a[k[x][0]:k[x][1]],b,x,param,c)) for x in range(d)]\n    for j in jobs:\n        j.start()\n    for j in jobs:\n        j.join()\n    \"\"\"for x in range(d):\n        k0,k1=k[x]\n        print(k0,k1)\n        threading.Thread(target=bw,args=(a[k0:k1],b,x,param)).start()\n    while True:\n        su=sum([int(param[x]==None) for x in range(d)])\n        print(su)\n        if su==0:\n            break\n        else:\n            time.sleep(1)\"\"\""
        },
        {
            "comment": "This code is creating a flattened list from a nested parameter 'param' with dimensions 'd'. It uses list comprehension to accomplish this and provides the option to join the resulting elements into a byte string or a regular string using multiprocessing.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/blitx/cruncher.py\":82-91",
            "content": "    result=[param[x] for x in range(d)]\n    result=[x for y in result for x in y]\n    # can increase complexity.\n    return result\n    #print(result)\n    # use multiprocessing.\n    \"\"\"if byte:\n        return b\"\".join(result)\n    else:\n        return \"\".join(result)\"\"\""
        }
    ]
}