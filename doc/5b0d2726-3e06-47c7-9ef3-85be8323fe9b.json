{
    "summary": "The script downloads and prepares dependencies for Rustup installation, detecting CPU architecture and OS type, supports various platforms, and ensures secure downloads with TLS v1.2 and strong cipher suites.",
    "details": [
        {
            "comment": "This script downloads and runs the Rustup installer, allowing users to easily set up Rust on Unix shells. It checks platform, sets environment variables, provides usage instructions, and offers flags for verbose output, disabling confirmation prompts or modifying PATH.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":0-30",
            "content": "#!/bin/sh\n# shellcheck shell=dash\n# This is just a little script that can be downloaded from the internet to\n# install rustup. It just does platform detection, downloads the installer\n# and runs it.\n# It runs on Unix shells like {a,ba,da,k,z}sh. It uses the common `local`\n# extension. Note: Most shells limit `local` to 1 var per line, contra bash.\nset -u\n# If RUSTUP_UPDATE_ROOT is unset or empty, default it.\nRUSTUP_UPDATE_ROOT=\"${RUSTUP_UPDATE_ROOT:-https://static.rust-lang.org/rustup}\"\n#XXX: If you change anything here, please make the same changes in setup_mode.rs\nusage() {\n    cat 1>&2 <<EOF\nrustup-init 1.22.1 (76644d669 2020-07-08)\nThe installer for rustup\nUSAGE:\n    rustup-init [FLAGS] [OPTIONS]\nFLAGS:\n    -v, --verbose           Enable verbose output\n    -q, --quiet             Disable progress output\n    -y                      Disable confirmation prompt.\n        --no-modify-path    Don't configure the PATH environment variable\n    -h, --help              Prints help information\n    -V, --version           Prints version information"
        },
        {
            "comment": "This code is setting up the necessary dependencies and downloading a file for installation. It checks the target architecture, creates a temporary directory, and downloads the appropriate executable (with .exe extension on Windows) to that directory. The purpose is likely to install or update Rust toolchain components and/or targets using rustup, which requires these prerequisites before proceeding with installation or updates.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":32-66",
            "content": "OPTIONS:\n        --default-host <default-host>              Choose a default host triple\n        --default-toolchain <default-toolchain>    Choose a default toolchain to install\n        --default-toolchain none                   Do not install any toolchains\n        --profile [minimal|default|complete]       Choose a profile\n    -c, --component <components>...                Component name to also install\n    -t, --target <targets>...                      Target name to also install\nEOF\n}\nmain() {\n    downloader --check\n    need_cmd uname\n    need_cmd mktemp\n    need_cmd chmod\n    need_cmd mkdir\n    need_cmd rm\n    need_cmd rmdir\n    get_architecture || return 1\n    local _arch=\"$RETVAL\"\n    assert_nz \"$_arch\" \"arch\"\n    local _ext=\"\"\n    case \"$_arch\" in\n        *windows*)\n            _ext=\".exe\"\n            ;;\n    esac\n    local _url=\"${RUSTUP_UPDATE_ROOT}/dist/${_arch}/rustup-init${_ext}\"\n    local _dir\n    _dir=\"$(mktemp -d 2>/dev/null || ensure mktemp -d -t rustup)\"\n    local _file=\"${_dir}/rustup-init${_ext}\""
        },
        {
            "comment": "This code checks if ANSI escapes are valid, prompts the user to download an installer, and ensures the installer is executable. It handles arguments like -h or --help, skips prompt with -y, and handles non-executable installers. The usage of printf and mkdir is evident.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":68-106",
            "content": "    local _ansi_escapes_are_valid=false\n    if [ -t 2 ]; then\n        if [ \"${TERM+set}\" = 'set' ]; then\n            case \"$TERM\" in\n                xterm*|rxvt*|urxvt*|linux*|vt*)\n                    _ansi_escapes_are_valid=true\n                ;;\n            esac\n        fi\n    fi\n    # check if we have to use /dev/tty to prompt the user\n    local need_tty=yes\n    for arg in \"$@\"; do\n        case \"$arg\" in\n            -h|--help)\n                usage\n                exit 0\n                ;;\n            -y)\n                # user wants to skip the prompt -- we don't need /dev/tty\n                need_tty=no\n                ;;\n            *)\n                ;;\n        esac\n    done\n    if $_ansi_escapes_are_valid; then\n        printf \"\\33[1minfo:\\33[0m downloading installer\\n\" 1>&2\n    else\n        printf '%s\\n' 'info: downloading installer' 1>&2\n    fi\n    ensure mkdir -p \"$_dir\"\n    ensure downloader \"$_url\" \"$_file\" \"$_arch\"\n    ensure chmod u+x \"$_file\"\n    if [ ! -x \"$_file\" ]; then\n        printf '%s\\n' \"Cannot execute $_file (likely because of mounting /tmp as noexec).\" 1>&2"
        },
        {
            "comment": "This code segment is responsible for handling interactive and non-interactive installations of rustup. It checks if the installation requires user interaction or not, sets up the necessary environment variables, removes temporary files and directories, and returns the exit status. Additionally, it provides architecture detection without dependencies using ELF file format.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":107-139",
            "content": "        printf '%s\\n' \"Please copy the file to a location where you can execute binaries and run ./rustup-init${_ext}.\" 1>&2\n        exit 1\n    fi\n    if [ \"$need_tty\" = \"yes\" ]; then\n        # The installer is going to want to ask for confirmation by\n        # reading stdin.  This script was piped into `sh` though and\n        # doesn't have stdin to pass to its children. Instead we're going\n        # to explicitly connect /dev/tty to the installer's stdin.\n        if [ ! -t 1 ]; then\n            err \"Unable to run interactively. Run with -y to accept defaults, --help for additional options\"\n        fi\n        ignore \"$_file\" \"$@\" < /dev/tty\n    else\n        ignore \"$_file\" \"$@\"\n    fi\n    local _retval=$?\n    ignore rm \"$_file\"\n    ignore rmdir \"$_dir\"\n    return \"$_retval\"\n}\nget_bitness() {\n    need_cmd head\n    # Architecture detection without dependencies beyond coreutils.\n    # ELF files start out \"\\x7fELF\", and the following byte is\n    #   0x01 for 32-bit and\n    #   0x02 for 64-bit.\n    # The printf builtin on some shells like dash only supports octal"
        },
        {
            "comment": "This code retrieves the platform bitness and endianness, as well as the operating system type and CPU architecture. It uses functions `get_bitness()`, `get_endianness()`, and `get_architecture()` to accomplish this by checking the file headers of the current executable and utilizing commands like `head`, `tail`, and `uname`. The retrieved information is then used for compatibility purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":140-176",
            "content": "    # escape sequences, so we use those.\n    local _current_exe_head\n    _current_exe_head=$(head -c 5 /proc/self/exe )\n    if [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\001')\" ]; then\n        echo 32\n    elif [ \"$_current_exe_head\" = \"$(printf '\\177ELF\\002')\" ]; then\n        echo 64\n    else\n        err \"unknown platform bitness\"\n    fi\n}\nget_endianness() {\n    local cputype=$1\n    local suffix_eb=$2\n    local suffix_el=$3\n    # detect endianness without od/hexdump, like get_bitness() does.\n    need_cmd head\n    need_cmd tail\n    local _current_exe_endianness\n    _current_exe_endianness=\"$(head -c 6 /proc/self/exe | tail -c 1)\"\n    if [ \"$_current_exe_endianness\" = \"$(printf '\\001')\" ]; then\n        echo \"${cputype}${suffix_el}\"\n    elif [ \"$_current_exe_endianness\" = \"$(printf '\\002')\" ]; then\n        echo \"${cputype}${suffix_eb}\"\n    else\n        err \"unknown platform endianness\"\n    fi\n}\nget_architecture() {\n    local _ostype _cputype _bitness _arch _clibtype\n    _ostype=\"$(uname -s)\"\n    _cputype=\"$(uname -m)\"\n    _clibtype=\"gnu\""
        },
        {
            "comment": "Code checks the operating system type and CPU architecture to determine the appropriate target system for rustup installation. It sets _ostype and _cputype variables accordingly, handling special cases like Android's uname -o and Darwin's hw.optional.x86_64. If the OS type is unrecognized, it displays an error message.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":178-227",
            "content": "    if [ \"$_ostype\" = Linux ]; then\n        if [ \"$(uname -o)\" = Android ]; then\n            _ostype=Android\n        fi\n        if ldd --version 2>&1 | grep -q 'musl'; then\n            _clibtype=\"musl\"\n        fi\n    fi\n    if [ \"$_ostype\" = Darwin ] && [ \"$_cputype\" = i386 ]; then\n        # Darwin `uname -m` lies\n        if sysctl hw.optional.x86_64 | grep -q ': 1'; then\n            _cputype=x86_64\n        fi\n    fi\n    case \"$_ostype\" in\n        Android)\n            _ostype=linux-android\n            ;;\n        Linux)\n            _ostype=unknown-linux-$_clibtype\n            _bitness=$(get_bitness)\n            ;;\n        FreeBSD)\n            _ostype=unknown-freebsd\n            ;;\n        NetBSD)\n            _ostype=unknown-netbsd\n            ;;\n        DragonFly)\n            _ostype=unknown-dragonfly\n            ;;\n        Darwin)\n            _ostype=apple-darwin\n            ;;\n        MINGW* | MSYS* | CYGWIN*)\n            _ostype=pc-windows-gnu\n            ;;\n        *)\n            err \"unrecognized OS type: $_ostype\"\n            ;;"
        },
        {
            "comment": "This code is part of a script used in a Rust development environment. It determines the CPU architecture, OS type and updates them accordingly based on conditions for different architectures like x86, arm, aarch64, etc., and OS types like Linux-Android. The _cputype and _ostype variables are updated based on these conditions.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":229-276",
            "content": "    esac\n    case \"$_cputype\" in\n        i386 | i486 | i686 | i786 | x86)\n            _cputype=i686\n            ;;\n        xscale | arm)\n            _cputype=arm\n            if [ \"$_ostype\" = \"linux-android\" ]; then\n                _ostype=linux-androideabi\n            fi\n            ;;\n        armv6l)\n            _cputype=arm\n            if [ \"$_ostype\" = \"linux-android\" ]; then\n                _ostype=linux-androideabi\n            else\n                _ostype=\"${_ostype}eabihf\"\n            fi\n            ;;\n        armv7l | armv8l)\n            _cputype=armv7\n            if [ \"$_ostype\" = \"linux-android\" ]; then\n                _ostype=linux-androideabi\n            else\n                _ostype=\"${_ostype}eabihf\"\n            fi\n            ;;\n        aarch64)\n            _cputype=aarch64\n            ;;\n        x86_64 | x86-64 | x64 | amd64)\n            _cputype=x86_64\n            ;;\n        mips)\n            _cputype=$(get_endianness mips '' el)\n            ;;\n        mips64)\n            if [ \"$_bitness\" -eq 64 ]; then\n                # only n64 ABI is supported for now"
        },
        {
            "comment": "Detecting CPU type and modifying _cputype based on the system architecture. If unknown-linux-gnu with 32-bit userland, adjusts _cputype accordingly for x86_64, mips64, powerpc64, aarch64 systems.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":277-320",
            "content": "                _ostype=\"${_ostype}abi64\"\n                _cputype=$(get_endianness mips64 '' el)\n            fi\n            ;;\n        ppc)\n            _cputype=powerpc\n            ;;\n        ppc64)\n            _cputype=powerpc64\n            ;;\n        ppc64le)\n            _cputype=powerpc64le\n            ;;\n        s390x)\n            _cputype=s390x\n            ;;\n        riscv64)\n            _cputype=riscv64gc\n            ;;\n        *)\n            err \"unknown CPU type: $_cputype\"\n    esac\n    # Detect 64-bit linux with 32-bit userland\n    if [ \"${_ostype}\" = unknown-linux-gnu ] && [ \"${_bitness}\" -eq 32 ]; then\n        case $_cputype in\n            x86_64)\n                _cputype=i686\n                ;;\n            mips64)\n                _cputype=$(get_endianness mips '' el)\n                ;;\n            powerpc64)\n                _cputype=powerpc\n                ;;\n            aarch64)\n                _cputype=armv7\n                if [ \"$_ostype\" = \"linux-android\" ]; then\n                    _ostype=linux-androideabi"
        },
        {
            "comment": "This code block is detecting the OS type, CPU type, and architecture to set appropriate values for variable \"_arch\". It also includes functions like \"say\", \"err\", \"need_cmd\", \"check_cmd\" and \"assert_nz\" for logging, error handling, checking command availability. The code block handles various scenarios such as armv7 with or without NEON support and unsupported riscv64 with 32-bit userland.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":321-369",
            "content": "                else\n                    _ostype=\"${_ostype}eabihf\"\n                fi\n                ;;\n            riscv64gc)\n                err \"riscv64 with 32-bit userland unsupported\"\n                ;;\n        esac\n    fi\n    # Detect armv7 but without the CPU features Rust needs in that build,\n    # and fall back to arm.\n    # See https://github.com/rust-lang/rustup.rs/issues/587.\n    if [ \"$_ostype\" = \"unknown-linux-gnueabihf\" ] && [ \"$_cputype\" = armv7 ]; then\n        if ensure grep '^Features' /proc/cpuinfo | grep -q -v neon; then\n            # At least one processor does not have NEON.\n            _cputype=arm\n        fi\n    fi\n    _arch=\"${_cputype}-${_ostype}\"\n    RETVAL=\"$_arch\"\n}\nsay() {\n    printf 'rustup: %s\\n' \"$1\"\n}\nerr() {\n    say \"$1\" >&2\n    exit 1\n}\nneed_cmd() {\n    if ! check_cmd \"$1\"; then\n        err \"need '$1' (command not found)\"\n    fi\n}\ncheck_cmd() {\n    command -v \"$1\" > /dev/null 2>&1\n}\nassert_nz() {\n    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\n}\n# Run a command that should never fail. If the command fails execution"
        },
        {
            "comment": "This code snippet contains three functions: `ensure`, `ignore`, and `downloader`. The `ensure` function checks if a command succeeds, otherwise it outputs an error message. The `ignore` function executes a command without considering its result. Lastly, the `downloader` function selects between `curl` or `wget` based on availability, with optional cipher suite enforcement and supports check/download operations.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":370-404",
            "content": "# will immediately terminate with an error showing the failing\n# command.\nensure() {\n    if ! \"$@\"; then err \"command failed: $*\"; fi\n}\n# This is just for indicating that commands' results are being\n# intentionally ignored. Usually, because it's being executed\n# as part of error handling.\nignore() {\n    \"$@\"\n}\n# This wraps curl or wget. Try curl first, if not installed,\n# use wget instead.\ndownloader() {\n    local _dld\n    local _ciphersuites\n    if check_cmd curl; then\n        _dld=curl\n    elif check_cmd wget; then\n        _dld=wget\n    else\n        _dld='curl or wget' # to be used in error message of need_cmd\n    fi\n    if [ \"$1\" = --check ]; then\n        need_cmd \"$_dld\"\n    elif [ \"$_dld\" = curl ]; then\n        get_ciphersuites_for_curl\n        _ciphersuites=\"$RETVAL\"\n        if [ -n \"$_ciphersuites\" ]; then\n            curl --proto '=https' --tlsv1.2 --ciphers \"$_ciphersuites\" --silent --show-error --fail --location \"$1\" --output \"$2\"\n        else\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\""
        },
        {
            "comment": "This code checks if TLS v1.2 is enforced and ensures strong cipher suites are used for secure downloading using either curl or wget commands. If not, it warns about potential security issues.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":405-423",
            "content": "            if ! check_help_for \"$3\" curl --proto --tlsv1.2; then\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\n                curl --silent --show-error --fail --location \"$1\" --output \"$2\"\n            else\n                curl --proto '=https' --tlsv1.2 --silent --show-error --fail --location \"$1\" --output \"$2\"\n            fi\n        fi\n    elif [ \"$_dld\" = wget ]; then\n        get_ciphersuites_for_wget\n        _ciphersuites=\"$RETVAL\"\n        if [ -n \"$_ciphersuites\" ]; then\n            wget --https-only --secure-protocol=TLSv1_2 --ciphers \"$_ciphersuites\" \"$1\" -O \"$2\"\n        else\n            echo \"Warning: Not enforcing strong cipher suites for TLS, this is potentially less secure\"\n            if ! check_help_for \"$3\" wget --https-only --secure-protocol; then\n                echo \"Warning: Not enforcing TLS v1.2, this is potentially less secure\"\n                wget \"$1\" -O \"$2\"\n            else\n                wget --https-only --secure-protocol=TLSv1_2 \"$1\" -O \"$2\""
        },
        {
            "comment": "This code checks if a specific argument exists in the help output of a command. If not found, it returns an error. The code also determines the cipher suite based on user input or strong TLS 1.2-1.3 suites if detected. It supports GnuTLS and OpenSSL (possibly LibreSSL and BoringSSL) for curl backends.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":424-467",
            "content": "            fi\n        fi\n    else\n        err \"Unknown downloader\"   # should not reach here\n    fi\n}\ncheck_help_for() {\n    local _arch\n    local _cmd\n    local _arg\n    _arch=\"$1\"\n    shift\n    _cmd=\"$1\"\n    shift\n    case \"$_arch\" in\n        # If we're running on OS-X, older than 10.13, then we always\n        # fail to find these options to force fallback\n        *darwin*)\n        if check_cmd sw_vers; then\n            if [ \"$(sw_vers -productVersion | cut -d. -f2)\" -lt 13 ]; then\n                # Older than 10.13\n                echo \"Warning: Detected OS X platform older than 10.13\"\n                return 1\n            fi\n        fi\n        ;;\n    esac\n    for _arg in \"$@\"; do\n        if ! \"$_cmd\" --help | grep -q -- \"$_arg\"; then\n            return 1\n        fi\n    done\n    true # not strictly needed\n}\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\n# if support by local tools is detected. Detection currently supports these curl backends: \n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty."
        },
        {
            "comment": "Function `get_ciphersuites_for_curl` retrieves TLS cipher suites for curl. If a custom suite is specified, it's assumed the user knows what they're doing. It checks curl's backend (OpenSSL, GnuTLS) and if supported arguments are available (\"unspecified\" for old OS).",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":468-499",
            "content": "get_ciphersuites_for_curl() {\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\n        # user specified custom cipher suites, assume they know what they're doing\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\n        return\n    fi\n    local _openssl_syntax=\"no\"\n    local _gnutls_syntax=\"no\"\n    local _backend_supported=\"yes\"\n    if curl -V | grep -q ' OpenSSL/'; then\n        _openssl_syntax=\"yes\"\n    elif curl -V | grep -iq ' LibreSSL/'; then\n        _openssl_syntax=\"yes\"\n    elif curl -V | grep -iq ' BoringSSL/'; then\n        _openssl_syntax=\"yes\"\n    elif curl -V | grep -iq ' GnuTLS/'; then\n        _gnutls_syntax=\"yes\"\n    else\n        _backend_supported=\"no\"\n    fi\n    local _args_supported=\"no\"\n    if [ \"$_backend_supported\" = \"yes\" ]; then\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\n        if check_help_for \"notspecified\" \"curl\" \"--tlsv1.2\" \"--ciphers\" \"--proto\"; then\n            _args_supported=\"yes\"\n        fi\n    fi\n    local _cs=\"\"\n    if [ \"$_args_supported\" = \"yes\" ]; then"
        },
        {
            "comment": "This function checks if the user has specified custom cipher suites. If not, it detects support for GnuTLS and OpenSSL backends in wget and returns strong TLS 1.2-1.3 cipher suites if found. The detected cipher suites are stored in the _cs variable and returned as RETVAL.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":500-523",
            "content": "        if [ \"$_openssl_syntax\" = \"yes\" ]; then\n            _cs=$(get_strong_ciphersuites_for \"openssl\")\n        elif [ \"$_gnutls_syntax\" = \"yes\" ]; then\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\n        fi\n    fi\n    RETVAL=\"$_cs\"\n}\n# Return cipher suite string specified by user, otherwise return strong TLS 1.2-1.3 cipher suites\n# if support by local tools is detected. Detection currently supports these wget backends: \n# GnuTLS and OpenSSL (possibly also LibreSSL and BoringSSL). Return value can be empty.\nget_ciphersuites_for_wget() {\n    if [ -n \"${RUSTUP_TLS_CIPHERSUITES-}\" ]; then\n        # user specified custom cipher suites, assume they know what they're doing\n        RETVAL=\"$RUSTUP_TLS_CIPHERSUITES\"\n        return\n    fi\n    local _cs=\"\"\n    if wget -V | grep -q '\\-DHAVE_LIBSSL'; then\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then"
        },
        {
            "comment": "This code checks the version of Wget and selects strong cipher suites (TLSv1_2) with ECDHE, AEAD, and excluding DHE due to weak parameters. It retrieves cipher suites in OpenSSL or GnuTLS syntax based on the input parameter, ensuring compatibility with Firefox 68 ESR settings for secure communication.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":524-544",
            "content": "            _cs=$(get_strong_ciphersuites_for \"openssl\")\n        fi\n    elif wget -V | grep -q '\\-DHAVE_LIBGNUTLS'; then\n        # \"unspecified\" is for arch, allows for possibility old OS using macports, homebrew, etc.\n        if check_help_for \"notspecified\" \"wget\" \"TLSv1_2\" \"--ciphers\" \"--https-only\" \"--secure-protocol\"; then\n            _cs=$(get_strong_ciphersuites_for \"gnutls\")\n        fi\n    fi\n    RETVAL=\"$_cs\"\n}\n# Return strong TLS 1.2-1.3 cipher suites in OpenSSL or GnuTLS syntax. TLS 1.2 \n# excludes non-ECDHE and non-AEAD cipher suites. DHE is excluded due to bad \n# DH params often found on servers (see RFC 7919). Sequence matches or is\n# similar to Firefox 68 ESR with weak cipher suites disabled via about:config.  \n# $1 must be openssl or gnutls.\nget_strong_ciphersuites_for() {\n    if [ \"$1\" = \"openssl\" ]; then\n        # OpenSSL is forgiving of unknown values, no problems with TLS 1.3 values on versions that don't support it yet.\n        echo \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA2"
        },
        {
            "comment": "This code checks the argument and if it is \"gnutls\", it outputs a string of cipher suites. GnuTLS does not support unknown values, so this produces a list that can be used for secure connections with GnuTLS, ensuring compatibility with TLS 1.3. The cipher suites are similar to OpenSSL but in slightly different order.",
            "location": "\"/media/root/Prima/works/generated_docs/lazero_doc/src/bootstrap/legacy/container_1/rustup.sh\":544-552",
            "content": "56:TLS_AES_256_GCM_SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384\"\n    elif [ \"$1\" = \"gnutls\" ]; then\n        # GnuTLS isn't forgiving of unknown values, so this may require a GnuTLS version that supports TLS 1.3 even if wget doesn't.\n        # Begin with SECURE128 (and higher) then remove/add to build cipher suites. Produces same 9 cipher suites as OpenSSL but in slightly different order.\n        echo \"SECURE128:-VERS-SSL3.0:-VERS-TLS1.0:-VERS-TLS1.1:-VERS-DTLS-ALL:-CIPHER-ALL:-MAC-ALL:-KX-ALL:+AEAD:+ECDHE-ECDSA:+ECDHE-RSA:+AES-128-GCM:+CHACHA20-POLY1305:+AES-256-GCM\"\n    fi \n}\nmain \"$@\" || exit 1"
        }
    ]
}